/**
 * ---------------------------------------------------------------------------------
 * This file has been generated by Sanity TypeGen.
 * Command: `sanity typegen generate`
 *
 * Any modifications made directly to this file will be overwritten the next time
 * the TypeScript definitions are generated. Please make changes to the Sanity
 * schema definitions and/or GROQ queries if you need to update these types.
 *
 * For more information on how to use Sanity TypeGen, visit the official documentation:
 * https://www.sanity.io/docs/sanity-typegen
 * ---------------------------------------------------------------------------------
 */

// Source: schema.json
export type ResourceItem = {
	_type: 'resourceItem';
	title: string;
	description: string;
	url: string;
};

export type SanityImageAssetReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'sanity.imageAsset';
};

export type EpisodeImage = {
	_type: 'episodeImage';
	asset?: SanityImageAssetReference;
	media?: unknown;
	hotspot?: SanityImageHotspot;
	crop?: SanityImageCrop;
	alt: string;
	caption?: string;
};

export type SanityImageCrop = {
	_type: 'sanity.imageCrop';
	top: number;
	bottom: number;
	left: number;
	right: number;
};

export type SanityImageHotspot = {
	_type: 'sanity.imageHotspot';
	x: number;
	y: number;
	height: number;
	width: number;
};

export type EpisodeTag = {
	_id: string;
	_type: 'episodeTag';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	label: string;
	slug: Slug;
	description?: string;
};

export type Slug = {
	_type: 'slug';
	current: string;
	source?: string;
};

export type Sponsor = {
	_id: string;
	_type: 'sponsor';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	title: string;
	slug: Slug;
	logo: CloudinaryAsset;
	link: string;
};

export type CloudinaryAsset = {
	_type: 'cloudinary.asset';
	public_id?: string;
	resource_type?: string;
	type?: string;
	format?: string;
	version?: number;
	url?: string;
	secure_url?: string;
	width?: number;
	height?: number;
	bytes?: number;
	duration?: number;
	tags?: Array<string>;
	created_at?: string;
	derived?: Array<
		{
			_key: string;
		} & CloudinaryAssetDerived
	>;
	access_mode?: string;
	context?: CloudinaryAssetContext;
};

export type Rules = {
	_id: string;
	_type: 'rules';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	title: string;
	description: string;
	weight: number;
	setAsDefault?: boolean;
};

export type Rewards = {
	_id: string;
	_type: 'rewards';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	title: string;
	description: string;
	image: CloudinaryAsset;
	weight: number;
	setAsDefault?: boolean;
};

export type Faq = {
	_id: string;
	_type: 'faq';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	question: string;
	answer: string;
	weight: number;
	setAsDefault?: boolean;
};

export type HackathonReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'hackathon';
};

export type PersonReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'person';
};

export type HackathonSubmission = {
	_id: string;
	_type: 'hackathonSubmission';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	hackathon: HackathonReference;
	person?: PersonReference;
	githubRepo: string;
	deployedUrl?: string;
	demoVideo?: string;
	submittedAt?: string;
};

export type HackathonSubmissionReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'hackathonSubmission';
};

export type Person = {
	_id: string;
	_type: 'person';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	name: string;
	slug: Slug;
	photo?: CloudinaryAsset;
	bio?: Markdown;
	links?: Array<{
		label?: string;
		url?: string;
		_type: 'link';
		_key: string;
	}>;
	subscription?: {
		customer?: string;
		level?:
			| 'Silver Tier Supporter'
			| 'Gold Tier Supporter'
			| 'Platinum Tier Supporter';
		status?:
			| 'incomplete'
			| 'incomplete_expired'
			| 'trialing'
			| 'active'
			| 'past_due'
			| 'canceled'
			| 'unpaid'
			| 'paused';
		date?: string;
	};
	user_id?: string;
	hackathons?: Array<
		{
			_key: string;
		} & HackathonReference
	>;
	hackathonSubmissions?: Array<
		{
			_key: string;
		} & HackathonSubmissionReference
	>;
};

export type Markdown = string;

export type EpisodeReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'episode';
};

export type RewardsReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'rewards';
};

export type FaqReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'faq';
};

export type SponsorReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'sponsor';
};

export type RulesReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'rules';
};

export type Hackathon = {
	_id: string;
	_type: 'hackathon';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	title: string;
	slug: Slug;
	pubDate: string;
	deadline: string;
	description: string;
	hero_image?: CloudinaryAsset;
	hero_title?: string;
	body: Markdown;
	episodes?: Array<
		{
			_key: string;
		} & EpisodeReference
	>;
	submissionForm: string;
	rewards?: Array<
		{
			_key: string;
		} & RewardsReference
	>;
	faq?: Array<
		{
			_key: string;
		} & FaqReference
	>;
	sponsors?: Array<
		{
			_key: string;
		} & SponsorReference
	>;
	rules?: Array<
		{
			_key: string;
		} & RulesReference
	>;
	resources?: Array<
		{
			_key: string;
		} & ResourceItem
	>;
	share_image: CloudinaryAsset;
	hidden?: 'visible' | 'hidden';
};

export type SanityFileAssetReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'sanity.fileAsset';
};

export type Extra = {
	_id: string;
	_type: 'extra';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	title: string;
	slug: Slug;
	publish_date: string;
	short_description: string;
	related_episode?: EpisodeReference;
	video?: {
		members_only?: 'public' | 'members';
		mux_video?: MuxVideo;
		youtube_id?: string;
		captions?: {
			asset?: SanityFileAssetReference;
			media?: unknown;
			_type: 'file';
		};
		thumbnail?: CloudinaryAsset;
		thumbnail_alt?: string;
		transcript?: Markdown;
	};
};

export type MuxVideoAssetReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'mux.videoAsset';
};

export type MuxVideo = {
	_type: 'mux.video';
	asset?: MuxVideoAssetReference;
};

export type Episode = {
	_id: string;
	_type: 'episode';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	title: string;
	slug: Slug;
	publish_date: string;
	short_description: string;
	description: Markdown;
	people?: Array<
		{
			_key: string;
		} & PersonReference
	>;
	sponsors?: Array<
		{
			_key: string;
		} & SponsorReference
	>;
	banner?: CloudinaryAsset;
	banner_alt?: string;
	hackathons?: Array<
		{
			_key: string;
		} & HackathonReference
	>;
	resources?: Array<{
		label?: string;
		url?: string;
		_type: 'resource';
		_key: string;
	}>;
	video?: {
		members_only?: 'public' | 'members';
		mux_video?: MuxVideo;
		youtube_id?: string;
		captions?: {
			asset?: SanityFileAssetReference;
			media?: unknown;
			_type: 'file';
		};
		thumbnail?: CloudinaryAsset;
		thumbnail_alt?: string;
		transcript?: Markdown;
	};
	hidden?: 'visible' | 'hidden';
	featured?: 'normal' | 'featured';
};

export type SeriesReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'series';
};

export type ExtraReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'extra';
};

export type Collection = {
	_id: string;
	_type: 'collection';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	title: string;
	slug: Slug;
	release_year: string;
	series: SeriesReference;
	episodes?: Array<
		{
			_key: string;
		} & EpisodeReference
	>;
	extras?: Array<
		{
			_key: string;
		} & ExtraReference
	>;
};

export type CollectionReference = {
	_ref: string;
	_type: 'reference';
	_weak?: boolean;
	[internalGroqTypeReferenceTo]?: 'collection';
};

export type Series = {
	_id: string;
	_type: 'series';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	title: string;
	slug: Slug;
	description: string;
	details: Markdown;
	logo: CloudinaryAsset;
	image?: CloudinaryAsset;
	banner?: CloudinaryAsset;
	banner_alt?: string;
	cover?: CloudinaryAsset;
	collections?: Array<
		{
			_key: string;
		} & CollectionReference
	>;
	sponsors?: Array<
		{
			_key: string;
		} & SponsorReference
	>;
	featured?: 'normal' | 'featured';
};

export type MuxVideoAsset = {
	_id: string;
	_type: 'mux.videoAsset';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	status?: string;
	assetId?: string;
	playbackId?: string;
	filename?: string;
	thumbTime?: number;
	data?: MuxAssetData;
};

export type MuxAssetData = {
	_type: 'mux.assetData';
	resolution_tier?: string;
	upload_id?: string;
	created_at?: string;
	id?: string;
	status?: string;
	max_stored_resolution?: string;
	passthrough?: string;
	encoding_tier?: string;
	video_quality?: string;
	master_access?: string;
	aspect_ratio?: string;
	duration?: number;
	max_stored_frame_rate?: number;
	mp4_support?: string;
	max_resolution_tier?: string;
	tracks?: Array<
		{
			_key: string;
		} & MuxTrack
	>;
	playback_ids?: Array<
		{
			_key: string;
		} & MuxPlaybackId
	>;
	static_renditions?: MuxStaticRenditions;
};

export type MuxStaticRenditions = {
	_type: 'mux.staticRenditions';
	status?: string;
	files?: Array<
		{
			_key: string;
		} & MuxStaticRenditionFile
	>;
};

export type MuxStaticRenditionFile = {
	_type: 'mux.staticRenditionFile';
	name?: string;
	ext?: string;
	height?: number;
	width?: number;
	bitrate?: number;
	filesize?: string;
	type?: string;
	status?: string;
	resolution_tier?: string;
	resolution?: string;
	id?: string;
	passthrough?: string;
};

export type MuxPlaybackId = {
	_type: 'mux.playbackId';
	id?: string;
	policy?: string;
};

export type MuxTrack = {
	_type: 'mux.track';
	id?: string;
	type?: string;
	max_width?: number;
	max_frame_rate?: number;
	duration?: number;
	max_height?: number;
};

export type CloudinaryAssetContextCustom = {
	_type: 'cloudinary.assetContextCustom';
	alt?: string;
	caption?: string;
};

export type CloudinaryAssetContext = {
	_type: 'cloudinary.assetContext';
	custom?: CloudinaryAssetContextCustom;
};

export type CloudinaryAssetDerived = {
	_type: 'cloudinary.assetDerived';
	raw_transformation?: string;
	url?: string;
	secure_url?: string;
};

export type SanityImagePaletteSwatch = {
	_type: 'sanity.imagePaletteSwatch';
	background?: string;
	foreground?: string;
	population?: number;
	title?: string;
};

export type SanityImagePalette = {
	_type: 'sanity.imagePalette';
	darkMuted?: SanityImagePaletteSwatch;
	lightVibrant?: SanityImagePaletteSwatch;
	darkVibrant?: SanityImagePaletteSwatch;
	vibrant?: SanityImagePaletteSwatch;
	dominant?: SanityImagePaletteSwatch;
	lightMuted?: SanityImagePaletteSwatch;
	muted?: SanityImagePaletteSwatch;
};

export type SanityImageDimensions = {
	_type: 'sanity.imageDimensions';
	height: number;
	width: number;
	aspectRatio: number;
};

export type SanityImageMetadata = {
	_type: 'sanity.imageMetadata';
	location?: Geopoint;
	dimensions?: SanityImageDimensions;
	palette?: SanityImagePalette;
	lqip?: string;
	blurHash?: string;
	thumbHash?: string;
	hasAlpha?: boolean;
	isOpaque?: boolean;
};

export type SanityFileAsset = {
	_id: string;
	_type: 'sanity.fileAsset';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	originalFilename?: string;
	label?: string;
	title?: string;
	description?: string;
	altText?: string;
	sha1hash?: string;
	extension?: string;
	mimeType?: string;
	size?: number;
	assetId?: string;
	uploadId?: string;
	path?: string;
	url?: string;
	source?: SanityAssetSourceData;
};

export type SanityAssetSourceData = {
	_type: 'sanity.assetSourceData';
	name?: string;
	id?: string;
	url?: string;
};

export type SanityImageAsset = {
	_id: string;
	_type: 'sanity.imageAsset';
	_createdAt: string;
	_updatedAt: string;
	_rev: string;
	originalFilename?: string;
	label?: string;
	title?: string;
	description?: string;
	altText?: string;
	sha1hash?: string;
	extension?: string;
	mimeType?: string;
	size?: number;
	assetId?: string;
	uploadId?: string;
	path?: string;
	url?: string;
	metadata?: SanityImageMetadata;
	source?: SanityAssetSourceData;
};

export type Geopoint = {
	_type: 'geopoint';
	lat?: number;
	lng?: number;
	alt?: number;
};

export type AllSanitySchemaTypes =
	| ResourceItem
	| SanityImageAssetReference
	| EpisodeImage
	| SanityImageCrop
	| SanityImageHotspot
	| EpisodeTag
	| Slug
	| Sponsor
	| CloudinaryAsset
	| Rules
	| Rewards
	| Faq
	| HackathonReference
	| PersonReference
	| HackathonSubmission
	| HackathonSubmissionReference
	| Person
	| Markdown
	| EpisodeReference
	| RewardsReference
	| FaqReference
	| SponsorReference
	| RulesReference
	| Hackathon
	| SanityFileAssetReference
	| Extra
	| MuxVideoAssetReference
	| MuxVideo
	| Episode
	| SeriesReference
	| ExtraReference
	| Collection
	| CollectionReference
	| Series
	| MuxVideoAsset
	| MuxAssetData
	| MuxStaticRenditions
	| MuxStaticRenditionFile
	| MuxPlaybackId
	| MuxTrack
	| CloudinaryAssetContextCustom
	| CloudinaryAssetContext
	| CloudinaryAssetDerived
	| SanityImagePaletteSwatch
	| SanityImagePalette
	| SanityImageDimensions
	| SanityImageMetadata
	| SanityFileAsset
	| SanityAssetSourceData
	| SanityImageAsset
	| Geopoint;

export declare const internalGroqTypeReferenceTo: unique symbol;

type ArrayOf<T> = Array<
	T & {
		_key: string;
	}
>;

// Source: ../../libs/sanity/src/index.ts
// Variable: allSeriesQuery
// Query: *[_type=="series"] {    title,    'slug': slug.current,    description,    image {      public_id,      height,      width,    },    cover {      public_id,      height,      width,    },    "collections": collections[]->{      title,      'slug': slug.current,      release_year,      'episode_count': count(episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))])    } | order(release_year desc),    'path': '/series/' + slug.current + '/' + collections[-1]->slug.current,    'total_episode_count': count(collections[]->episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))]),    'total_season_count': count(collections[]),    'latestEpisodeDate': collections[]->episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))] | order(@->publish_date desc)[0]->publish_date,    featured  } | order(latestEpisodeDate desc)
export type AllSeriesQueryResult = Array<{
	title: string;
	slug: string;
	description: string;
	image: {
		public_id: string | null;
		height: number | null;
		width: number | null;
	} | null;
	cover: {
		public_id: string | null;
		height: number | null;
		width: number | null;
	} | null;
	collections: Array<{
		title: string;
		slug: string;
		release_year: string;
		episode_count: number | null;
	}> | null;
	path: string | null;
	total_episode_count: number | null;
	total_season_count: number | null;
	latestEpisodeDate: string | null;
	featured: 'featured' | 'normal' | null;
}>;

// Source: ../../libs/sanity/src/index.ts
// Variable: featuredSeriesQuery
// Query: *[_type=="series" && featured == 'featured'] {    'slug': slug.current,    title,    description,    image {      public_id,      height,      width,    },    cover {      public_id,      height,      width,    },    'path': '/series/' + slug.current + '/' + collections[-1]->slug.current,    'total_episode_count': count(collections[]->episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))]),    'total_season_count': count(collections[])  }
export type FeaturedSeriesQueryResult = Array<{
	slug: string;
	title: string;
	description: string;
	image: {
		public_id: string | null;
		height: number | null;
		width: number | null;
	} | null;
	cover: {
		public_id: string | null;
		height: number | null;
		width: number | null;
	} | null;
	path: string | null;
	total_episode_count: number | null;
	total_season_count: number | null;
}>;

// Source: ../../libs/sanity/src/index.ts
// Variable: seriesBySlugQuery
// Query: *[_type=="series" && slug.current==$series][0] {    title,    'slug': slug.current,    description,    details,    'banner': {      'public_id': banner.public_id,      'alt': banner_alt,    },    'logo': logo.public_id,    image {      public_id,      height,      width,    },    cover {      public_id,      height,      width,    },    'sponsors': sponsors[]->{      'title': title,      logo {        public_id,        width,        height      },      link,    },    'collection': collections[@->slug.current==$collection && @->series._ref==^._id][0]->{      title,      'slug': slug.current,      release_year,      'logo': logo.public_id,      episodes[@->hidden != true]->{        title,        'slug': slug.current,        short_description,        publish_date,        'banner': {          'public_id': banner.public_id,          'alt': banner_alt,        },        'thumbnail': {          'public_id': video.thumbnail.public_id,          'alt': video.thumbnail_alt,          'width': video.thumbnail.width,          'height': video.thumbnail.height,        },        video {          youtube_id,          mux_video,          members_only        },        'sponsors': sponsors[]->{          title,          logo {            public_id,            width,            height          },          link,        },      },      extras[]->{        title,        'slug': slug.current,        short_description,        publish_date,        video {          youtube_id,          mux_video,          members_only        },      }    },    collections[]->{      title,      'slug': slug.current,      release_year,      'episode_count': count(episodes[@->hidden != true])    }  }
export type SeriesBySlugQueryResult = {
	title: string;
	slug: string;
	description: string;
	details: Markdown;
	banner: {
		public_id: string | null;
		alt: string | null;
	};
	logo: string | null;
	image: {
		public_id: string | null;
		height: number | null;
		width: number | null;
	} | null;
	cover: {
		public_id: string | null;
		height: number | null;
		width: number | null;
	} | null;
	sponsors: Array<{
		title: string;
		logo: {
			public_id: string | null;
			width: number | null;
			height: number | null;
		};
		link: string;
	}> | null;
	collection: {
		title: string;
		slug: string;
		release_year: string;
		logo: null;
		episodes: Array<{
			title: string;
			slug: string;
			short_description: string;
			publish_date: string;
			banner: {
				public_id: string | null;
				alt: string | null;
			};
			thumbnail: {
				public_id: string | null;
				alt: string | null;
				width: number | null;
				height: number | null;
			};
			video: {
				youtube_id: string | null;
				mux_video: MuxVideo | null;
				members_only: 'members' | 'public' | null;
			} | null;
			sponsors: Array<{
				title: string;
				logo: {
					public_id: string | null;
					width: number | null;
					height: number | null;
				};
				link: string;
			}> | null;
		}> | null;
		extras: Array<{
			title: string;
			slug: string;
			short_description: string;
			publish_date: string;
			video: {
				youtube_id: string | null;
				mux_video: MuxVideo | null;
				members_only: 'members' | 'public' | null;
			} | null;
		}> | null;
	} | null;
	collections: Array<{
		title: string;
		slug: string;
		release_year: string;
		episode_count: number | null;
	}> | null;
} | null;

// Source: ../../libs/sanity/src/index.ts
// Variable: allEpisodesQuery
// Query: *[_type=="episode" && hidden != true] {    title,    'slug': slug.current,    description,    short_description,    publish_date,    'thumbnail': {      'public_id': video.thumbnail.public_id,      'width': video.thumbnail.width,      'height': video.thumbnail.height,      'alt': video.thumbnail_alt,    },    'banner': {      'public_id': banner.public_id,      'alt': banner_alt,    },    video {      youtube_id,      'mux': mux_video.asset->data.playback_ids,      'captions': captions.asset->url,      transcript,    },    people[]-> {      user_id,      name,      "slug": slug.current,      photo {        public_id      }    },    resources[] {      label,      url,    },    'sponsors': sponsors[]->{      title,      logo {        public_id,        width,        height      },      link,    },    'related_episodes': *[_type=="collection" && references(^._id)][0].episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))]-> {      title,      'slug': slug.current,      short_description,      publish_date,      'thumbnail': {        'public_id': video.thumbnail.public_id,        'width': video.thumbnail.width,        'height': video.thumbnail.height,        'alt': video.thumbnail_alt,      },      video {        youtube_id      }    },    'collection': *[_type=="collection" && references(^._id)][0] {      'slug': slug.current,      title,      'episodeSlugs': episodes[]->slug.current,    },    'series': *[_type=="collection" && references(^._id)][0].series->{      'slug': slug.current,      title,    },    'hackathons': hackathons[]-> {      'slug': slug.current,      title,      deadline,      'sponsors': sponsors[]->{        title,        logo {          public_id,          width,          height        },        link,      },    },  }
export type AllEpisodesQueryResult = Array<{
	title: string;
	slug: string;
	description: Markdown;
	short_description: string;
	publish_date: string;
	thumbnail: {
		public_id: string | null;
		width: number | null;
		height: number | null;
		alt: string | null;
	};
	banner: {
		public_id: string | null;
		alt: string | null;
	};
	video: {
		youtube_id: string | null;
		mux: Array<
			{
				_key: string;
			} & MuxPlaybackId
		> | null;
		captions: string | null;
		transcript: Markdown | null;
	} | null;
	people: Array<{
		user_id: string | null;
		name: string;
		slug: string;
		photo: {
			public_id: string | null;
		} | null;
	}> | null;
	resources: Array<{
		label: string | null;
		url: string | null;
	}> | null;
	sponsors: Array<{
		title: string;
		logo: {
			public_id: string | null;
			width: number | null;
			height: number | null;
		};
		link: string;
	}> | null;
	related_episodes: Array<{
		title: string;
		slug: string;
		short_description: string;
		publish_date: string;
		thumbnail: {
			public_id: string | null;
			width: number | null;
			height: number | null;
			alt: string | null;
		};
		video: {
			youtube_id: string | null;
		} | null;
	}> | null;
	collection: {
		slug: string;
		title: string;
		episodeSlugs: Array<string> | null;
	} | null;
	series: {
		slug: string;
		title: string;
	} | null;
	hackathons: Array<{
		slug: string;
		title: string;
		deadline: string;
		sponsors: Array<{
			title: string;
			logo: {
				public_id: string | null;
				width: number | null;
				height: number | null;
			};
			link: string;
		}> | null;
	}> | null;
}>;

// Source: ../../libs/sanity/src/index.ts
// Variable: episodeBySlugQuery
// Query: *[_type=="episode" && slug.current==$episode][0] {    title,    'slug': slug.current,    description,    short_description,    publish_date,    'banner': {      'public_id': banner.public_id,      'alt': banner_alt,    },    'thumbnail': {      'public_id': video.thumbnail.public_id,      'width': video.thumbnail.width,      'height': video.thumbnail.height,      'alt': video.thumbnail_alt,    },    video {      youtube_id,      'mux': mux_video.asset->data.playback_ids,      'captions': captions.asset->url,      transcript,    },    people[]-> {      user_id,      name,      "slug": slug.current,      photo {        public_id      }    },    resources[] {      label,      url,    },    'sponsors': sponsors[]->{      title,      logo {        public_id,        width,        height      },      link,    },    'related_episodes': *[_type=="collection" && references(^._id)][0].episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))]-> {      title,      'slug': slug.current,      short_description,      publish_date,      'thumbnail': {        'public_id': video.thumbnail.public_id,        'width': video.thumbnail.width,        'height': video.thumbnail.height,        'alt': video.thumbnail_alt,      },      video {        youtube_id      }    },    'collection': *[_type=="collection" && references(^._id)][0] {      'slug': slug.current,      title,      'episodeSlugs': episodes[]->slug.current,    },    'series': *[_type=="collection" && references(^._id)][0].series->{      'slug': slug.current,      title,    },  }
export type EpisodeBySlugQueryResult = {
	title: string;
	slug: string;
	description: Markdown;
	short_description: string;
	publish_date: string;
	banner: {
		public_id: string | null;
		alt: string | null;
	};
	thumbnail: {
		public_id: string | null;
		width: number | null;
		height: number | null;
		alt: string | null;
	};
	video: {
		youtube_id: string | null;
		mux: Array<
			{
				_key: string;
			} & MuxPlaybackId
		> | null;
		captions: string | null;
		transcript: Markdown | null;
	} | null;
	people: Array<{
		user_id: string | null;
		name: string;
		slug: string;
		photo: {
			public_id: string | null;
		} | null;
	}> | null;
	resources: Array<{
		label: string | null;
		url: string | null;
	}> | null;
	sponsors: Array<{
		title: string;
		logo: {
			public_id: string | null;
			width: number | null;
			height: number | null;
		};
		link: string;
	}> | null;
	related_episodes: Array<{
		title: string;
		slug: string;
		short_description: string;
		publish_date: string;
		thumbnail: {
			public_id: string | null;
			width: number | null;
			height: number | null;
			alt: string | null;
		};
		video: {
			youtube_id: string | null;
		} | null;
	}> | null;
	collection: {
		slug: string;
		title: string;
		episodeSlugs: Array<string> | null;
	} | null;
	series: {
		slug: string;
		title: string;
	} | null;
} | null;

// Source: ../../libs/sanity/src/index.ts
// Variable: episodeTranscriptBySlugQuery
// Query: *[_type=="episode" && slug.current==$episode][0].video.transcript
export type EpisodeTranscriptBySlugQueryResult = Markdown | null;

// Source: ../../libs/sanity/src/index.ts
// Variable: earlyAccessEpisodesQuery
// Query: *[_type=="episode" && dateTime(publish_date) > dateTime(now()) && defined(video.mux_video) && hidden != true] {    title,    'slug': slug.current,    short_description,    publish_date,    'thumbnail': {      'public_id': video.thumbnail.public_id,      'width': video.thumbnail.width,      'height': video.thumbnail.height,      'alt': video.thumbnail_alt,    },    'youtube_id': video.youtube_id,    'path': "/series/" + *[_type=="collection" && references(^._id)][0].series->slug.current + "/" + *[_type=="collection" && references(^._id)][0].slug.current + "/" + slug.current,    'series': *[_type=="collection" && references(^._id)][0].series->title,    'collection_number': upper(*[_type=="collection" && references(^._id)][0].slug.current),    'episodes': *[_type=="collection" && references(^._id)][0].episodes[]->slug.current,  }
export type EarlyAccessEpisodesQueryResult = Array<{
	title: string;
	slug: string;
	short_description: string;
	publish_date: string;
	thumbnail: {
		public_id: string | null;
		width: number | null;
		height: number | null;
		alt: string | null;
	};
	youtube_id: string | null;
	path: string | null;
	series: string | null;
	collection_number: string | null;
	episodes: Array<string> | null;
}>;

// Source: ../../libs/sanity/src/index.ts
// Variable: recentEpisodesQuery
// Query: *[_type=="episode" && dateTime(publish_date) < dateTime(now()) && (defined(video.youtube_id) || defined(video.mux_video)) && hidden != true] {    title,    'slug': slug.current,    short_description,    publish_date,    'thumbnail': {      'public_id': video.thumbnail.public_id,      'width': video.thumbnail.width,      'height': video.thumbnail.height,      'alt': video.thumbnail_alt,    },    'youtube_id': video.youtube_id,    'path': "/series/" + *[_type=="collection" && references(^._id)][0].series->slug.current + "/" + *[_type=="collection" && references(^._id)][0].slug.current + "/" + slug.current,    'series': *[_type=="collection" && references(^._id)][0].series->title,    'collection_number': upper(*[_type=="collection" && references(^._id)][0].slug.current),    'episodes': *[_type=="collection" && references(^._id)][0].episodes[]->slug.current,  } | order(publish_date desc)[0..7]
export type RecentEpisodesQueryResult = Array<{
	title: string;
	slug: string;
	short_description: string;
	publish_date: string;
	thumbnail: {
		public_id: string | null;
		width: number | null;
		height: number | null;
		alt: string | null;
	};
	youtube_id: string | null;
	path: string | null;
	series: string | null;
	collection_number: string | null;
	episodes: Array<string> | null;
}>;

// Source: ../../libs/sanity/src/index.ts
// Variable: upcomingEpisodeBySeriesQuery
// Query: *[ _type == "collection" && series->slug.current == $seriesSlug] {    title,    "schedule": episodes[dateTime(@->publish_date) > dateTime(now()) && !defined(@->video.youtube_id) && !defined(@->video.mux_video) && @->hidden != true]-> {      title,      "slug": slug.current,      short_description,      publish_date,      "thumbnail": {        "src": video.thumbnail.public_id,        "alt": video.thumbnail_alt,      }    }  }
export type UpcomingEpisodeBySeriesQueryResult = Array<{
	title: string;
	schedule: Array<{
		title: string;
		slug: string;
		short_description: string;
		publish_date: string;
		thumbnail: {
			src: string | null;
			alt: string | null;
		};
	}> | null;
}>;

// Source: ../../libs/sanity/src/index.ts
// Variable: personByIdQuery
// Query: *[_type == "person" && user_id == $user_id][0] {    _id,    name,    photo {      public_id,      height,      width,    },    bio,    links[],    user_id,    "episodes": *[_type == "episode" && hidden!=true && references(^._id) && (defined(@->video.youtube_id) || defined(@->video.mux_video))] {      title,      'slug': slug.current,      short_description,      publish_date,      'thumbnail': {        'public_id': video.thumbnail.public_id,        'alt': video.thumbnail_alt,        'width': video.thumbnail.width,        'height': video.thumbnail.height,      },      video {        youtube_id,      },      'collection': *[_type=="collection" && references(^._id)][0] {        'slug': slug.current,        title,        'episodeSlugs': episodes[]->slug.current,      },      'series': *[_type=="collection" && references(^._id)][0].series->{        'slug': slug.current,        title,      },    } | order(publish_date desc)[0...4]  }
export type PersonByIdQueryResult = {
	_id: string;
	name: string;
	photo: {
		public_id: string | null;
		height: number | null;
		width: number | null;
	} | null;
	bio: Markdown | null;
	links: Array<{
		label?: string;
		url?: string;
		_type: 'link';
		_key: string;
	}> | null;
	user_id: string | null;
	episodes: Array<never>;
} | null;

// Source: ../../libs/sanity/src/index.ts
// Variable: allUsersQuery
// Query: *[_type=="person"] | order(name asc) | order(subscription.level asc) {    _id,    name,    "slug": slug.current,    bio,    photo {      public_id,      height,      width,    },    subscription {      "cus_id": customer,      level,      status,      date    },    user_id,    links[] {      label,      url    },    "episodes": *[_type == "episode" && references(^._id) && hidden != true && (defined(video.youtube_id) || defined(video.mux_video))] {      title,      'slug': slug.current,      short_description,      publish_date,      'thumbnail': {        'public_id': video.thumbnail.public_id,        'alt': video.thumbnail_alt,        'width': video.thumbnail.width,        'height': video.thumbnail.height,      },      video {        youtube_id,      },      'collection': *[_type=="collection" && references(^._id)][0] {        'slug': slug.current,        title,        'episodeSlugs': episodes[]->slug.current,      },      'series': *[_type=="collection" && references(^._id)][0].series->{        'slug': slug.current,        title,      },    } | order(publish_date desc)[0...6]  }
export type AllUsersQueryResult = Array<{
	_id: string;
	name: string;
	slug: string;
	bio: Markdown | null;
	photo: {
		public_id: string | null;
		height: number | null;
		width: number | null;
	} | null;
	subscription: {
		cus_id: string | null;
		level:
			| 'Gold Tier Supporter'
			| 'Platinum Tier Supporter'
			| 'Silver Tier Supporter'
			| null;
		status:
			| 'active'
			| 'canceled'
			| 'incomplete_expired'
			| 'incomplete'
			| 'past_due'
			| 'paused'
			| 'trialing'
			| 'unpaid'
			| null;
		date: string | null;
	} | null;
	user_id: string | null;
	links: Array<{
		label: string | null;
		url: string | null;
	}> | null;
	episodes: Array<{
		title: string;
		slug: string;
		short_description: string;
		publish_date: string;
		thumbnail: {
			public_id: string | null;
			alt: string | null;
			width: number | null;
			height: number | null;
		};
		video: {
			youtube_id: string | null;
		} | null;
		collection: {
			slug: string;
			title: string;
			episodeSlugs: Array<string> | null;
		} | null;
		series: {
			slug: string;
			title: string;
		} | null;
	}>;
}>;

// Source: ../../libs/sanity/src/index.ts
// Variable: personBySlugQuery
// Query: *[_type == "person" && slug.current == $slug][0] {    _id,    name,    "slug": slug.current,    photo {      public_id,      height,      width,    },    bio,    links[],    user_id,    "episodes": *[_type == "episode" && references(^._id) && hidden != true && (defined(video.youtube_id) || defined(video.mux_video))] {      title,      'slug': slug.current,      short_description,      publish_date,      'thumbnail': {        'public_id': video.thumbnail.public_id,        'alt': video.thumbnail_alt,        'width': video.thumbnail.width,        'height': video.thumbnail.height,      },      video {        youtube_id,      },      'collection': *[_type=="collection" && references(^._id)][0] {        'slug': slug.current,        title,        'episodeSlugs': episodes[]->slug.current,      },      'series': *[_type=="collection" && references(^._id)][0].series->{        'slug': slug.current,        title,      },    } | order(publish_date desc)[0...6]  }
export type PersonBySlugQueryResult = {
	_id: string;
	name: string;
	slug: string;
	photo: {
		public_id: string | null;
		height: number | null;
		width: number | null;
	} | null;
	bio: Markdown | null;
	links: Array<{
		label?: string;
		url?: string;
		_type: 'link';
		_key: string;
	}> | null;
	user_id: string | null;
	episodes: Array<{
		title: string;
		slug: string;
		short_description: string;
		publish_date: string;
		thumbnail: {
			public_id: string | null;
			alt: string | null;
			width: number | null;
			height: number | null;
		};
		video: {
			youtube_id: string | null;
		} | null;
		collection: {
			slug: string;
			title: string;
			episodeSlugs: Array<string> | null;
		} | null;
		series: {
			slug: string;
			title: string;
		} | null;
	}>;
} | null;

// Source: ../../libs/sanity/src/index.ts
// Variable: personByClerkIdQuery
// Query: *[_type == "person" && user_id == $user_id][0] {    _id,    name,    slug,    user_id,  }
export type PersonByClerkIdQueryResult = {
	_id: string;
	name: string;
	slug: Slug;
	user_id: string | null;
} | null;

// Source: ../../libs/sanity/src/index.ts
// Variable: supportersQuery
// Query: *[_type == "person" && subscription.status == "active"] | order(subscription.date asc) {    _id,    name,    photo {      public_id,      height,      width,    },    'username': slug.current,    subscription {      level,      status    }  }
export type SupportersQueryResult = Array<{
	_id: string;
	name: string;
	photo: {
		public_id: string | null;
		height: number | null;
		width: number | null;
	} | null;
	username: string;
	subscription: {
		level:
			| 'Gold Tier Supporter'
			| 'Platinum Tier Supporter'
			| 'Silver Tier Supporter'
			| null;
		status: 'active';
	};
}>;

// Source: ../../libs/sanity/src/index.ts
// Variable: allHackathonsQuery
// Query: *[_type == "hackathon" && hidden != "hidden"] | order(pubDate desc) {    _id,    title,    'slug': slug.current,    pubDate,    deadline,    description,    body,    hero_image {      public_id,      width,      height,    },    hero_title,    episodes[]-> {      _id,      title,      'slug': slug.current,      'path': "/series/" + *[_type=="collection" && references(^._id)][0].series->slug.current + "/" + *[_type=="collection" && references(^._id)][0].slug.current + "/" + slug.current,      short_description,      publish_date,      'thumbnail': {        'public_id': video.thumbnail.public_id,        'width': video.thumbnail.width,        'height': video.thumbnail.height,        'alt': video.thumbnail_alt,      }    },    share_image {      public_id,      width,      height,    },    hidden  }
export type AllHackathonsQueryResult = Array<{
	_id: string;
	title: string;
	slug: string;
	pubDate: string;
	deadline: string;
	description: string;
	body: Markdown;
	hero_image: {
		public_id: string | null;
		width: number | null;
		height: number | null;
	} | null;
	hero_title: string | null;
	episodes: Array<{
		_id: string;
		title: string;
		slug: string;
		path: string | null;
		short_description: string;
		publish_date: string;
		thumbnail: {
			public_id: string | null;
			width: number | null;
			height: number | null;
			alt: string | null;
		};
	}> | null;
	share_image: {
		public_id: string | null;
		width: number | null;
		height: number | null;
	};
	hidden: 'hidden' | 'visible' | null;
}>;

// Source: ../../libs/sanity/src/index.ts
// Variable: hackathonBySlugQuery
// Query: *[_type == "hackathon" && slug.current == $slug][0] {    _id,    title,    'slug': slug.current,    description,    body,    pubDate,    deadline,    submissionForm,    hero_image {      public_id,      width,      height,    },    hero_title,    'episode': episodes[0]-> {      title,      'slug': slug.current,      'path': "/series/" + *[_type=="collection" && references(^._id)][0].series->slug.current + "/" + *[_type=="collection" && references(^._id)][0].slug.current + "/" + slug.current,      'thumbnail': {        'public_id': video.thumbnail.public_id,        'width': video.thumbnail.width,        'height': video.thumbnail.height,        'alt': video.thumbnail_alt,      },      video {        youtube_id,        'mux': mux_video.asset->data.playback_ids,      }    },    'sponsors': sponsors[]->{      title,      logo {        public_id,        width,        height      },      link,    },    'rewardsData': rewards[]-> {      title,      description,      image {        public_id,        width,        height,      },      weight    } | order(weight asc),    'faqData': faq[]-> {      question,      answer,      weight    } | order(weight asc),    rules[]-> {      title,      description,      weight    } | order(weight asc),    resources[] {      title,      description,      url,    },    share_image {      public_id,      width,      height,    },    hidden  }
export type HackathonBySlugQueryResult = {
	_id: string;
	title: string;
	slug: string;
	description: string;
	body: Markdown;
	pubDate: string;
	deadline: string;
	submissionForm: string;
	hero_image: {
		public_id: string | null;
		width: number | null;
		height: number | null;
	} | null;
	hero_title: string | null;
	episode: {
		title: string;
		slug: string;
		path: string | null;
		thumbnail: {
			public_id: string | null;
			width: number | null;
			height: number | null;
			alt: string | null;
		};
		video: {
			youtube_id: string | null;
			mux: Array<
				{
					_key: string;
				} & MuxPlaybackId
			> | null;
		} | null;
	} | null;
	sponsors: Array<{
		title: string;
		logo: {
			public_id: string | null;
			width: number | null;
			height: number | null;
		};
		link: string;
	}> | null;
	rewardsData: Array<{
		title: string;
		description: string;
		image: {
			public_id: string | null;
			width: number | null;
			height: number | null;
		};
		weight: number;
	}> | null;
	faqData: Array<{
		question: string;
		answer: string;
		weight: number;
	}> | null;
	rules: Array<{
		title: string;
		description: string;
		weight: number;
	}> | null;
	resources: Array<{
		title: string;
		description: string;
		url: string;
	}> | null;
	share_image: {
		public_id: string | null;
		width: number | null;
		height: number | null;
	};
	hidden: 'hidden' | 'visible' | null;
} | null;

// Source: ../../libs/sanity/src/index.ts
// Variable: activeHackathonQuery
// Query: *[_type == "hackathon" && hidden != "hidden" && dateTime(pubDate) <= dateTime(now()) && dateTime(deadline) > dateTime(now())] | order(pubDate desc)[0] {    _id,    'slug': slug.current,  }
export type ActiveHackathonQueryResult = {
	_id: string;
	slug: string;
} | null;

// Source: ../../libs/sanity/src/index.ts
// Variable: allSponsorsForCollectionQuery
// Query: *[_type=="series" && slug.current==$series][0] {    'sponsors': collections[@->slug.current==$collection && @->series._ref==^._id][0]->episodes[@->hidden != true]->sponsors[]->{      title,      logo {        public_id,        width,        height      },      link,    }  }
export type AllSponsorsForCollectionQueryResult = {
	sponsors: Array<{
		title: string;
		logo: {
			public_id: string | null;
			width: number | null;
			height: number | null;
		};
		link: string;
	} | null> | null;
} | null;

// Query TypeMap
import '@sanity/client';
declare module '@sanity/client' {
	interface SanityQueries {
		"\n  *[_type==\"series\"] {\n    title,\n    'slug': slug.current,\n    description,\n    image {\n      public_id,\n      height,\n      width,\n    },\n    cover {\n      public_id,\n      height,\n      width,\n    },\n    \"collections\": collections[]->{\n      title,\n      'slug': slug.current,\n      release_year,\n      'episode_count': count(episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))])\n    } | order(release_year desc),\n    'path': '/series/' + slug.current + '/' + collections[-1]->slug.current,\n    'total_episode_count': count(collections[]->episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))]),\n    'total_season_count': count(collections[]),\n    'latestEpisodeDate': collections[]->episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))] | order(@->publish_date desc)[0]->publish_date,\n    featured\n  } | order(latestEpisodeDate desc)\n": AllSeriesQueryResult;
		"\n  *[_type==\"series\" && featured == 'featured'] {\n    'slug': slug.current,\n    title,\n    description,\n    image {\n      public_id,\n      height,\n      width,\n    },\n    cover {\n      public_id,\n      height,\n      width,\n    },\n    'path': '/series/' + slug.current + '/' + collections[-1]->slug.current,\n    'total_episode_count': count(collections[]->episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))]),\n    'total_season_count': count(collections[])\n  }\n": FeaturedSeriesQueryResult;
		"\n  *[_type==\"series\" && slug.current==$series][0] {\n    title,\n    'slug': slug.current,\n    description,\n    details,\n    'banner': {\n      'public_id': banner.public_id,\n      'alt': banner_alt,\n    },\n    'logo': logo.public_id,\n    image {\n      public_id,\n      height,\n      width,\n    },\n    cover {\n      public_id,\n      height,\n      width,\n    },\n    'sponsors': sponsors[]->{\n      'title': title,\n      logo {\n        public_id,\n        width,\n        height\n      },\n      link,\n    },\n    'collection': collections[@->slug.current==$collection && @->series._ref==^._id][0]->{\n      title,\n      'slug': slug.current,\n      release_year,\n      'logo': logo.public_id,\n      episodes[@->hidden != true]->{\n        title,\n        'slug': slug.current,\n        short_description,\n        publish_date,\n        'banner': {\n          'public_id': banner.public_id,\n          'alt': banner_alt,\n        },\n        'thumbnail': {\n          'public_id': video.thumbnail.public_id,\n          'alt': video.thumbnail_alt,\n          'width': video.thumbnail.width,\n          'height': video.thumbnail.height,\n        },\n        video {\n          youtube_id,\n          mux_video,\n          members_only\n        },\n        'sponsors': sponsors[]->{\n          title,\n          logo {\n            public_id,\n            width,\n            height\n          },\n          link,\n        },\n      },\n      extras[]->{\n        title,\n        'slug': slug.current,\n        short_description,\n        publish_date,\n        video {\n          youtube_id,\n          mux_video,\n          members_only\n        },\n      }\n    },\n    collections[]->{\n      title,\n      'slug': slug.current,\n      release_year,\n      'episode_count': count(episodes[@->hidden != true])\n    }\n  }\n": SeriesBySlugQueryResult;
		"\n  *[_type==\"episode\" && hidden != true] {\n    title,\n    'slug': slug.current,\n    description,\n    short_description,\n    publish_date,\n    'thumbnail': {\n      'public_id': video.thumbnail.public_id,\n      'width': video.thumbnail.width,\n      'height': video.thumbnail.height,\n      'alt': video.thumbnail_alt,\n    },\n    'banner': {\n      'public_id': banner.public_id,\n      'alt': banner_alt,\n    },\n    video {\n      youtube_id,\n      'mux': mux_video.asset->data.playback_ids,\n      'captions': captions.asset->url,\n      transcript,\n    },\n    people[]-> {\n      user_id,\n      name,\n      \"slug\": slug.current,\n      photo {\n        public_id\n      }\n    },\n    resources[] {\n      label,\n      url,\n    },\n    'sponsors': sponsors[]->{\n      title,\n      logo {\n        public_id,\n        width,\n        height\n      },\n      link,\n    },\n    'related_episodes': *[_type==\"collection\" && references(^._id)][0].episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))]-> {\n      title,\n      'slug': slug.current,\n      short_description,\n      publish_date,\n      'thumbnail': {\n        'public_id': video.thumbnail.public_id,\n        'width': video.thumbnail.width,\n        'height': video.thumbnail.height,\n        'alt': video.thumbnail_alt,\n      },\n      video {\n        youtube_id\n      }\n    },\n    'collection': *[_type==\"collection\" && references(^._id)][0] {\n      'slug': slug.current,\n      title,\n      'episodeSlugs': episodes[]->slug.current,\n    },\n    'series': *[_type==\"collection\" && references(^._id)][0].series->{\n      'slug': slug.current,\n      title,\n    },\n    'hackathons': hackathons[]-> {\n      'slug': slug.current,\n      title,\n      deadline,\n      'sponsors': sponsors[]->{\n        title,\n        logo {\n          public_id,\n          width,\n          height\n        },\n        link,\n      },\n    },\n  }\n": AllEpisodesQueryResult;
		"\n  *[_type==\"episode\" && slug.current==$episode][0] {\n    title,\n    'slug': slug.current,\n    description,\n    short_description,\n    publish_date,\n    'banner': {\n      'public_id': banner.public_id,\n      'alt': banner_alt,\n    },\n    'thumbnail': {\n      'public_id': video.thumbnail.public_id,\n      'width': video.thumbnail.width,\n      'height': video.thumbnail.height,\n      'alt': video.thumbnail_alt,\n    },\n    video {\n      youtube_id,\n      'mux': mux_video.asset->data.playback_ids,\n      'captions': captions.asset->url,\n      transcript,\n    },\n    people[]-> {\n      user_id,\n      name,\n      \"slug\": slug.current,\n      photo {\n        public_id\n      }\n    },\n    resources[] {\n      label,\n      url,\n    },\n    'sponsors': sponsors[]->{\n      title,\n      logo {\n        public_id,\n        width,\n        height\n      },\n      link,\n    },\n    'related_episodes': *[_type==\"collection\" && references(^._id)][0].episodes[@->hidden != true && (defined(@->video.youtube_id) || defined(@->video.mux_video))]-> {\n      title,\n      'slug': slug.current,\n      short_description,\n      publish_date,\n      'thumbnail': {\n        'public_id': video.thumbnail.public_id,\n        'width': video.thumbnail.width,\n        'height': video.thumbnail.height,\n        'alt': video.thumbnail_alt,\n      },\n      video {\n        youtube_id\n      }\n    },\n    'collection': *[_type==\"collection\" && references(^._id)][0] {\n      'slug': slug.current,\n      title,\n      'episodeSlugs': episodes[]->slug.current,\n    },\n    'series': *[_type==\"collection\" && references(^._id)][0].series->{\n      'slug': slug.current,\n      title,\n    },\n  }\n": EpisodeBySlugQueryResult;
		'\n  *[_type=="episode" && slug.current==$episode][0].video.transcript\n': EpisodeTranscriptBySlugQueryResult;
		"\n  *[_type==\"episode\" && dateTime(publish_date) > dateTime(now()) && defined(video.mux_video) && hidden != true] {\n    title,\n    'slug': slug.current,\n    short_description,\n    publish_date,\n    'thumbnail': {\n      'public_id': video.thumbnail.public_id,\n      'width': video.thumbnail.width,\n      'height': video.thumbnail.height,\n      'alt': video.thumbnail_alt,\n    },\n    'youtube_id': video.youtube_id,\n    'path': \"/series/\" + *[_type==\"collection\" && references(^._id)][0].series->slug.current + \"/\" + *[_type==\"collection\" && references(^._id)][0].slug.current + \"/\" + slug.current,\n    'series': *[_type==\"collection\" && references(^._id)][0].series->title,\n    'collection_number': upper(*[_type==\"collection\" && references(^._id)][0].slug.current),\n    'episodes': *[_type==\"collection\" && references(^._id)][0].episodes[]->slug.current,\n  }\n": EarlyAccessEpisodesQueryResult;
		"\n  *[_type==\"episode\" && dateTime(publish_date) < dateTime(now()) && (defined(video.youtube_id) || defined(video.mux_video)) && hidden != true] {\n    title,\n    'slug': slug.current,\n    short_description,\n    publish_date,\n    'thumbnail': {\n      'public_id': video.thumbnail.public_id,\n      'width': video.thumbnail.width,\n      'height': video.thumbnail.height,\n      'alt': video.thumbnail_alt,\n    },\n    'youtube_id': video.youtube_id,\n    'path': \"/series/\" + *[_type==\"collection\" && references(^._id)][0].series->slug.current + \"/\" + *[_type==\"collection\" && references(^._id)][0].slug.current + \"/\" + slug.current,\n    'series': *[_type==\"collection\" && references(^._id)][0].series->title,\n    'collection_number': upper(*[_type==\"collection\" && references(^._id)][0].slug.current),\n    'episodes': *[_type==\"collection\" && references(^._id)][0].episodes[]->slug.current,\n  } | order(publish_date desc)[0..7]\n": RecentEpisodesQueryResult;
		'\n  *[ _type == "collection" && series->slug.current == $seriesSlug] {\n    title,\n    "schedule": episodes[dateTime(@->publish_date) > dateTime(now()) && !defined(@->video.youtube_id) && !defined(@->video.mux_video) && @->hidden != true]-> {\n      title,\n      "slug": slug.current,\n      short_description,\n      publish_date,\n      "thumbnail": {\n        "src": video.thumbnail.public_id,\n        "alt": video.thumbnail_alt,\n      }\n    }\n  }\n': UpcomingEpisodeBySeriesQueryResult;
		"\n  *[_type == \"person\" && user_id == $user_id][0] {\n    _id,\n    name,\n    photo {\n      public_id,\n      height,\n      width,\n    },\n    bio,\n    links[],\n    user_id,\n    \"episodes\": *[_type == \"episode\" && hidden!=true && references(^._id) && (defined(@->video.youtube_id) || defined(@->video.mux_video))] {\n      title,\n      'slug': slug.current,\n      short_description,\n      publish_date,\n      'thumbnail': {\n        'public_id': video.thumbnail.public_id,\n        'alt': video.thumbnail_alt,\n        'width': video.thumbnail.width,\n        'height': video.thumbnail.height,\n      },\n      video {\n        youtube_id,\n      },\n      'collection': *[_type==\"collection\" && references(^._id)][0] {\n        'slug': slug.current,\n        title,\n        'episodeSlugs': episodes[]->slug.current,\n      },\n      'series': *[_type==\"collection\" && references(^._id)][0].series->{\n        'slug': slug.current,\n        title,\n      },\n    } | order(publish_date desc)[0...4]\n  }\n": PersonByIdQueryResult;
		"\n  *[_type==\"person\"] | order(name asc) | order(subscription.level asc) {\n    _id,\n    name,\n    \"slug\": slug.current,\n    bio,\n    photo {\n      public_id,\n      height,\n      width,\n    },\n    subscription {\n      \"cus_id\": customer,\n      level,\n      status,\n      date\n    },\n    user_id,\n    links[] {\n      label,\n      url\n    },\n    \"episodes\": *[_type == \"episode\" && references(^._id) && hidden != true && (defined(video.youtube_id) || defined(video.mux_video))] {\n      title,\n      'slug': slug.current,\n      short_description,\n      publish_date,\n      'thumbnail': {\n        'public_id': video.thumbnail.public_id,\n        'alt': video.thumbnail_alt,\n        'width': video.thumbnail.width,\n        'height': video.thumbnail.height,\n      },\n      video {\n        youtube_id,\n      },\n      'collection': *[_type==\"collection\" && references(^._id)][0] {\n        'slug': slug.current,\n        title,\n        'episodeSlugs': episodes[]->slug.current,\n      },\n      'series': *[_type==\"collection\" && references(^._id)][0].series->{\n        'slug': slug.current,\n        title,\n      },\n    } | order(publish_date desc)[0...6]\n  }\n": AllUsersQueryResult;
		"\n  *[_type == \"person\" && slug.current == $slug][0] {\n    _id,\n    name,\n    \"slug\": slug.current,\n    photo {\n      public_id,\n      height,\n      width,\n    },\n    bio,\n    links[],\n    user_id,\n    \"episodes\": *[_type == \"episode\" && references(^._id) && hidden != true && (defined(video.youtube_id) || defined(video.mux_video))] {\n      title,\n      'slug': slug.current,\n      short_description,\n      publish_date,\n      'thumbnail': {\n        'public_id': video.thumbnail.public_id,\n        'alt': video.thumbnail_alt,\n        'width': video.thumbnail.width,\n        'height': video.thumbnail.height,\n      },\n      video {\n        youtube_id,\n      },\n      'collection': *[_type==\"collection\" && references(^._id)][0] {\n        'slug': slug.current,\n        title,\n        'episodeSlugs': episodes[]->slug.current,\n      },\n      'series': *[_type==\"collection\" && references(^._id)][0].series->{\n        'slug': slug.current,\n        title,\n      },\n    } | order(publish_date desc)[0...6]\n  }\n": PersonBySlugQueryResult;
		'\n  *[_type == "person" && user_id == $user_id][0] {\n    _id,\n    name,\n    slug,\n    user_id,\n  }\n': PersonByClerkIdQueryResult;
		'\n  *[_type == "person" && subscription.status == "active"] | order(subscription.date asc) {\n    _id,\n    name,\n    photo {\n      public_id,\n      height,\n      width,\n    },\n    \'username\': slug.current,\n    subscription {\n      level,\n      status\n    }\n  }\n': SupportersQueryResult;
		"\n  *[_type == \"hackathon\" && hidden != \"hidden\"] | order(pubDate desc) {\n    _id,\n    title,\n    'slug': slug.current,\n    pubDate,\n    deadline,\n    description,\n    body,\n    hero_image {\n      public_id,\n      width,\n      height,\n    },\n    hero_title,\n    episodes[]-> {\n      _id,\n      title,\n      'slug': slug.current,\n      'path': \"/series/\" + *[_type==\"collection\" && references(^._id)][0].series->slug.current + \"/\" + *[_type==\"collection\" && references(^._id)][0].slug.current + \"/\" + slug.current,\n      short_description,\n      publish_date,\n      'thumbnail': {\n        'public_id': video.thumbnail.public_id,\n        'width': video.thumbnail.width,\n        'height': video.thumbnail.height,\n        'alt': video.thumbnail_alt,\n      }\n    },\n    share_image {\n      public_id,\n      width,\n      height,\n    },\n    hidden\n  }\n": AllHackathonsQueryResult;
		"\n  *[_type == \"hackathon\" && slug.current == $slug][0] {\n    _id,\n    title,\n    'slug': slug.current,\n    description,\n    body,\n    pubDate,\n    deadline,\n    submissionForm,\n    hero_image {\n      public_id,\n      width,\n      height,\n    },\n    hero_title,\n    'episode': episodes[0]-> {\n      title,\n      'slug': slug.current,\n      'path': \"/series/\" + *[_type==\"collection\" && references(^._id)][0].series->slug.current + \"/\" + *[_type==\"collection\" && references(^._id)][0].slug.current + \"/\" + slug.current,\n      'thumbnail': {\n        'public_id': video.thumbnail.public_id,\n        'width': video.thumbnail.width,\n        'height': video.thumbnail.height,\n        'alt': video.thumbnail_alt,\n      },\n      video {\n        youtube_id,\n        'mux': mux_video.asset->data.playback_ids,\n      }\n    },\n    'sponsors': sponsors[]->{\n      title,\n      logo {\n        public_id,\n        width,\n        height\n      },\n      link,\n    },\n    'rewardsData': rewards[]-> {\n      title,\n      description,\n      image {\n        public_id,\n        width,\n        height,\n      },\n      weight\n    } | order(weight asc),\n    'faqData': faq[]-> {\n      question,\n      answer,\n      weight\n    } | order(weight asc),\n    rules[]-> {\n      title,\n      description,\n      weight\n    } | order(weight asc),\n    resources[] {\n      title,\n      description,\n      url,\n    },\n    share_image {\n      public_id,\n      width,\n      height,\n    },\n    hidden\n  }\n": HackathonBySlugQueryResult;
		'\n  *[_type == "hackathon" && hidden != "hidden" && dateTime(pubDate) <= dateTime(now()) && dateTime(deadline) > dateTime(now())] | order(pubDate desc)[0] {\n    _id,\n    \'slug\': slug.current,\n  }\n': ActiveHackathonQueryResult;
		'\n  *[_type=="series" && slug.current==$series][0] {\n    \'sponsors\': collections[@->slug.current==$collection && @->series._ref==^._id][0]->episodes[@->hidden != true]->sponsors[]->{\n      title,\n      logo {\n        public_id,\n        width,\n        height\n      },\n      link,\n    }\n  }\n': AllSponsorsForCollectionQueryResult;
	}
}
